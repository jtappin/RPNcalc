! Copyright (C) 2011
! James Tappin

! This is free software; you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation; either version 3, or (at your option)
! any later version.

! This software is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.

! You should have received a copy of the GNU General Public License along with
! this program; see the files COPYING3 and COPYING.RUNTIME respectively.
! If not, see <http://www.gnu.org/licenses/>.

module handlers
  ! This module contains the signal handlers for RPNcalc, including those that
  ! are required by transient widgets generated by other handlers. 

  use iso_c_binding
  use g, only: g_signal_stop_emission_by_name

  use gtk, only: gtk_about_dialog_new, gtk_about_dialog_set_authors, &
       & gtk_about_dialog_set_comments, gtk_about_dialog_set_license, &
       & gtk_about_dialog_set_program_name, gtk_about_dialog_set_website, &
       & gtk_check_menu_item_get_active, gtk_container_add, gtk_dialog_run, &
       & gtk_editable_copy_clipboard, gtk_editable_cut_clipboard, &
       & gtk_editable_delete_selection, gtk_editable_delete_text, &
       & gtk_editable_get_chars, gtk_editable_get_selection_bounds, &
       & gtk_editable_insert_text, gtk_editable_paste_clipboard, &
       & gtk_editable_set_position, gtk_entry_get_text, &
       & gtk_entry_get_text_length, gtk_entry_set_text, gtk_label_new, &
       & gtk_main_quit, gtk_menu_item_set_label, gtk_statusbar_push, &
       & gtk_toggle_button_get_active, gtk_toggle_button_set_active, &
       & gtk_widget_destroy, gtk_widget_grab_focus, gtk_widget_set_sensitive, &
       & gtk_widget_show_all, gtk_window_set_transient_for, &
       & gtk_combo_box_get_active, gtk_spin_button_get_value_as_int, &
       & TRUE, FALSE

  use iso_fortran_env, only: error_unit

  use gtk_sup
  use gtk_hl
  use widgets
  use utils

  implicit none

  ! Constants (these are used both in main and some handlers)
  real(kind=c_double), parameter :: pi = 3.1415926535897932384626433832795029_c_double

contains

  subroutine my_destroy (widget, gdata) bind(c)
    ! Destroy the heirarchy.

    use iso_c_binding, only: c_ptr
    type(c_ptr), value :: widget, gdata
    call gtk_widget_destroy(win)
    call gtk_main_quit ()
  end subroutine my_destroy

  subroutine enter_value(widget, gdata) bind(c)
    ! Enter key or <Enter> in the input window, transfer the value to the stack
    type(c_ptr), value :: widget, gdata

    real(kind=c_double) :: val
    logical :: status
    integer(kind=c_int) :: mid

    mid = gtk_statusbar_push(fstatus, 0_c_int, c_null_char)
    call read_entry(val, status, push=.true.)
    if (.not. status) return
    call gtk_entry_set_text(fentry, c_null_char)
    call set_result(val)
  end subroutine enter_value

  subroutine char_entered(widget, ctext, nchars, ppos, gdata) bind(c)
    ! A few basic sanity checks on numeric entry
    type(c_ptr), value :: widget, ctext, ppos, gdata
    integer(kind=c_int), value :: nchars

    character(len=40) :: itext, etext, otext, wtext
    integer(kind=c_int) :: nentry
    type(c_ptr) :: cetext
    integer(kind=c_int), pointer :: ipos
    integer :: i, j
    integer(kind=c_int) :: mid
    logical :: dflag, eflag, svalid
    integer(kind=c_int), target :: opcode

    ! Error codes for invalid inputs.
    integer, parameter :: err_ok =       0   ! No error
    integer, parameter :: err_invalid =  1   ! Invalid character
    integer, parameter :: err_exponent = 2   ! Exponent in invalid place
    integer, parameter :: err_decimal =  4   ! Decimal in invalid place
    integer, parameter :: err_operator = 8   ! Operator in invalid place
    integer, parameter :: err_numeral = 16   ! Number in invalid place

    integer :: error_code

    call convert_c_string(ctext, itext)
    call c_f_pointer(ppos, ipos)
    if (ipos == 0) itext=adjustl(itext)

    nentry = gtk_entry_get_text_length(widget)
    cetext = gtk_entry_get_text(widget)
    call convert_c_string(cetext, etext)

    eflag=.false.
    dflag=.false.

    j=1
    opcode=OP_NONE
    error_code = err_ok
    do i = 1, nchars
       select case(itext(i:i))
       case('0':'9') ! A number, OK except before a sign
          if (ipos == 0 .and. nentry >= 1) then  ! at start of line
             if (etext(1:1) == '+' .or. etext(1:1) == '-') then
                error_code = ior(error_code, err_numeral)
                cycle
             end if
          else if (exponent_present .and. ipos < nentry) then
             if (scan(etext(ipos:ipos), "EeDd") /= 0 .and. &
                  & scan(etext(ipos+1:ipos+1), "+-") /= 0) then
                error_code = ior(error_code, err_numeral)
                cycle
             end if
          end if
          otext(j:j) = itext(i:i)
          j = j+1

       case('.') ! A decimal point (OK if there's not already one present
          ! and it's not after an exponent
          if (decimal_present) then
             error_code = ior(error_code, err_decimal)
             cycle
          end if
          if (exponent_present) then
             if (i > 1) then
                if (scan(itext(:i-1), "EeDd") > 0) then
                   error_code = ior(error_code, err_decimal)
                   cycle
                end if
             end if
             if (ipos > 0) then
                if (scan(etext(:ipos),"EeDd") > 0) then
                   error_code = ior(error_code, err_decimal)
                   cycle
                end if
             end if
          end if
          otext(j:j) = itext(i:i)
          j = j+1
          dflag = .true.

       case("E","D","e","d") ! An exponent (OK if there isn't already one
          ! and it's not before a decimal, and there's at least 1 number
          ! before it)
          if (exponent_present) then
             error_code = ior(error_code, err_exponent)
             cycle
          end if
          if (decimal_present) then
             if (i < len_trim(itext)) then
                if (index(itext(i+1:),'.') > 0) then
                   error_code = ior(error_code, err_exponent)
                   cycle
                end if
             end if
             if (ipos < nchars-1) then
                if (index(etext(ipos+1:),'.') > 0) then
                   error_code = ior(error_code, err_exponent)
                   cycle
                end if
             end if
          end if
          if (scan(etext(:ipos),"0123456789") == 0 .and. &
               & scan(itext(:i),"0123456789") == 0) then
             error_code = ior(error_code, err_exponent)
             cycle
          end if
          otext(j:j) = itext(i:i)
          j = j+1
          eflag = .true.

       case("+","-") ! A sign (OK at the start or immediately after
          ! an exponent, or at the very end when it's an operator.
          ! The end placement is only accepted if a single character
          ! is entered (for safety in the case of an incomplete selection).
          svalid=.true.
          if (i > 1) then
             if (scan(itext(i-1:i-1), "EeDd") == 0) svalid=.false.
          else if (ipos == 0) then
             if (scan(etext(1:1), "+-") /= 0) svalid=.false.
          end if
          if (ipos > 0) then
             if (scan(etext(ipos:ipos), "EeDd") == 0) svalid=.false.
             if (scan(etext(ipos+1:), "+-") /= 0) svalid=.false.
          end if
          if (svalid) then
             otext(j:j) = itext(i:i)
             j = j+1
          else if (nchars == 1 .and. ipos == nentry .and. &
               & nchars+nentry > 1) then
             if (itext(i:i) == '+') then
                opcode = OP_PLUS
             else
                opcode = OP_MINUS
             endif
             exit
          else
             error_code = ior(error_code, err_operator)
             cycle
          end if

       case("*","/","^") ! Operators other than + & -
          ! Only accepted for a single character at the end of the field.
          if (nchars == 1 .and. ipos == nentry) then
             select case(itext(i:i))
             case("*")
                opcode = OP_TIMES
             case("/")
                opcode = OP_DIVIDE
             case("^")
                opcode = OP_POWER
             end select
             exit
          else
             error_code = ior(error_code, err_operator)
             cycle
          end if

       case default  ! Anything else is invalid
          error_code = ior(error_code, err_invalid)
       end select
    end do

    if (j <= nchars) then ! We had to exclude some chars otherwise let the
       ! default handler do it.
       select case (error_code)
       case (err_invalid)
          mid = gtk_statusbar_push(fstatus, 0_c_int, &
               & "Entered text includes invalid characters -- excluded"// &
               & c_null_char)
       case (err_exponent)
          mid = gtk_statusbar_push(fstatus, 0_c_int, &
               & "Entered text includes misplaced exponent -- ignored"// &
               & c_null_char)
       case (err_decimal) 
          mid = gtk_statusbar_push(fstatus, 0_c_int, &
               & "Entered text includes misplaced decimal -- ignored"// &
               & c_null_char)
       case (err_operator)
          mid = gtk_statusbar_push(fstatus, 0_c_int, &
               & "Entered text includes misplaced operator -- ignored"// &
               & c_null_char)
       case (err_numeral)
          mid = gtk_statusbar_push(fstatus, 0_c_int, &
               & "A numeral may not immediately precede a sign -- ignored"// &
               & c_null_char)
       case(err_ok)   ! Don't put an error message if the cause was
          ! a valid operator
       case default   ! More than one of the above
          mid = gtk_statusbar_push(fstatus, 0_c_int, &
               & "Entered text includes errors -- ignored"// &
               & c_null_char)
       end select

       if (j > 0) then
          if (ipos > 0) then
             wtext = etext(:ipos)//otext(:j-1)
          else
             wtext = otext(:j-1)
          endif
          if (ipos < nentry) then
             wtext = trim(wtext)//trim(etext(ipos+1:))
          end if
          call gtk_entry_set_text(widget, trim(wtext)//c_null_char)
       endif
       if (dflag) decimal_present = .true.
       if (eflag) exponent_present = .true.
       if (opcode /= OP_NONE) call oppress(C_NULL_PTR, c_loc(opcode))
       ipos = ipos+j-1

       call g_signal_stop_emission_by_name(widget, "insert-text")
    else
       if (dflag) decimal_present = .true.
       if (eflag) exponent_present = .true.
    end if
  end subroutine char_entered

  subroutine char_deleted(widget, istart, iend, gdata) bind(c)
    ! When characters are deleted, check what's deleted and clear
    ! flags if needed
    type(c_ptr), value :: widget, gdata
    integer(kind=c_int), value :: istart, iend

    type(c_ptr) :: cetext
    integer(kind=c_int) :: nchars
    character(len=40) :: etext
    integer :: iloc

    nchars = gtk_entry_get_text_length(widget)
    cetext = gtk_entry_get_text(widget)

    if (iend < 0) iend = nchars-1
    call convert_c_string(cetext, etext)

    ! Was there an exponent marker in the deleted segment?
    iloc = scan(etext(istart+1:iend+1), "EeDd")
    if (iloc > 0) exponent_present = .false.

    iloc = index(etext(istart+1:iend+1), '.')
    if (iloc > 0) decimal_present = .false.

  end subroutine char_deleted

  subroutine menu_cut(widget, gdata) bind(c)
    ! Cut the selection to the clipboard.
    type(c_ptr), value :: widget, gdata

    call gtk_editable_cut_clipboard(fentry)

  end subroutine menu_cut
  subroutine menu_delete(widget, gdata) bind(c)
    ! Cut the selection to the clipboard.
    type(c_ptr), value :: widget, gdata

    call gtk_editable_delete_selection(fentry)

  end subroutine menu_delete

  subroutine menu_copy(widget, gdata) bind(c)
    ! Copy the selection to the clipboard.
    type(c_ptr), value :: widget, gdata

    if (c_f_logical(gtk_editable_get_selection_bounds(fentry, &
         & c_null_ptr, c_null_ptr))) then
       call gtk_editable_copy_clipboard(fentry)
    else if (c_f_logical(gtk_editable_get_selection_bounds(fresult, &
         & c_null_ptr, c_null_ptr))) then
       call gtk_editable_copy_clipboard(fresult)
    end if
  end subroutine menu_copy

  subroutine menu_paste(widget, gdata) bind(c)
    ! Paste from the clipboard.
    type(c_ptr), value :: widget, gdata

    call gtk_editable_paste_clipboard(fentry)

  end subroutine menu_paste

  subroutine numpress(widget, gdata) bind(c)
    ! Keypad number entry -- gdata will be a pointer to the number
    type(c_ptr), value :: widget, gdata

    character, pointer :: fdata
    integer(kind=c_int) :: mid

    mid = gtk_statusbar_push(fstatus, 0_c_int, c_null_char)
    if (c_associated(gdata)) then
       call c_f_pointer(gdata, fdata)
       call append_char_entry(fdata//c_null_char)
    end if

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end


  end subroutine numpress

  subroutine dppress(widget, gdata) bind(c)
    ! Keypad decimal point
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: mid

    if (decimal_present .or. exponent_present) then
       mid = gtk_statusbar_push(fstatus, 0_c_int, &
            & "Decimal point not permitted here"//c_null_char)
    else
       call append_char_entry("."//c_null_char)
       decimal_present = .TRUE.
    end if

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

  end subroutine dppress

  subroutine chspress(widget, gdata) bind(c)
    ! The change sign key (+/-)
    type(c_ptr), value :: widget, gdata

    type(c_ptr) :: ctext
    character :: ftext
    integer(kind=c_int), target :: pos
    character(len=40) :: alltext
    integer(kind=c_int) :: nchars, mid
    integer :: idx
    real(kind=c_double) :: x
    logical :: status

    mid = gtk_statusbar_push(fstatus, 0_c_int, c_null_char)
    nchars = int(gtk_entry_get_text_length(fentry), c_int)
    if (exponent_present) then
       ctext = gtk_entry_get_text(fentry)
       call convert_c_string(ctext, alltext)
       idx = max(index(alltext, 'E'), index(alltext,'e'), &
            & index(alltext, 'D'), index(alltext, 'd'))
       if (idx == 0) then
          mid = gtk_statusbar_push(fstatus, 0_c_int, "D'Oh"//c_null_char)
       else
          idx=idx+1
          select case(alltext(idx:idx))
          case ('+')
             alltext(idx:idx) = '-'
          case('-')
             alltext = alltext(:idx-1)//alltext(idx+1:)
          case default
             alltext = alltext(:idx-1)//'-'//alltext(idx:)
          end select
          call gtk_entry_set_text(fentry, trim(alltext)//c_null_char)
       end if
    else if (nchars > 0) then
       ctext = gtk_editable_get_chars(fentry, 0_c_int, 1_c_int)
       call convert_c_string(ctext, ftext)
       pos = 0
       select case(ftext)
       case ('+')
          call gtk_editable_delete_text(fentry, 0_c_int, 1_c_int)
          call gtk_editable_insert_text(fentry, '-'//c_null_char, &
               & 1_c_int, c_loc(pos))
       case ('-')
          call gtk_editable_delete_text(fentry, 0_c_int, 1_c_int)
       case default  ! no sign present
          call gtk_editable_insert_text(fentry, '-'//c_null_char, &
               & 1_c_int, c_loc(pos))
       end select
    else
       call set_result()
       call pop_stack(x, status)
       if (status) then
          x = -x
          call push_stack(x)
       end if
    end if

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

  end subroutine chspress

  subroutine eepress(widget, gdata) bind(c)
    ! Exponent entry key (EE)
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: mid, nchars
    integer(kind=c_int), target :: pos

    if (exponent_present) then
       mid = gtk_statusbar_push(fstatus, 0_c_int, &
            & "Exponent already present"//c_null_char)
    else
       nchars = int(gtk_entry_get_text_length(fentry), c_int)
       if (nchars == 0) then
          mid = gtk_statusbar_push(fstatus, 0_c_int, &
               & "Must have a mantissa before an exponent."//c_null_char)
       else
          pos = nchars
          call gtk_editable_insert_text(fentry, 'E'//c_null_char, &
               & 1_c_int, c_loc(pos))
          exponent_present = .true.
       end if
    end if

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

  end subroutine eepress

  subroutine pipress(widget, gdata) bind(c)
    ! The PI key
    type(c_ptr), value :: widget, gdata

    call push_stack(pi)
    call gtk_entry_set_text(fentry, c_null_char)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

  end subroutine pipress

  subroutine add_const(widget, gdata) bind(c)
    ! Physics constants
    type(c_ptr), value :: widget, gdata

    real(kind=c_double), pointer :: cval

    call c_f_pointer(gdata, cval)

    call push_stack(cval)
    call gtk_entry_set_text(fentry, c_null_char)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

  end subroutine add_const

  subroutine delpress(widget, gdata) bind(c)
    ! The del key -- delete the last character in the entry window
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: nchars
    character :: last
    type(c_ptr) :: clast

    nchars = int(gtk_entry_get_text_length(fentry), c_int)
    if (nchars == 0) return

    clast = gtk_editable_get_chars(fentry, nchars-1_c_int, nchars)
    call convert_c_string(clast, last)
    call gtk_editable_delete_text(fentry, nchars-1_c_int, nchars)

    select case(last)
    case('.')
       decimal_present = .false.
    case('E','e','D','d')
       exponent_present = .false.
    end select


    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

  end subroutine delpress

  subroutine duppress(widget, gdata) bind(c)
    ! The dup key. If there is a value in the entry window, copy it to the
    ! stack; if not, duplicate the top entry on the stack.
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: nchars, mid
    real(kind=c_double) :: val
    logical :: status

    mid = gtk_statusbar_push(fstatus, 0_c_int, c_null_char)
    nchars = int(gtk_entry_get_text_length(fentry), c_int)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

    if (nchars == 0) then
       call pop_stack(val, status, readonly=.TRUE.)
       if (.not. status) return
       call push_stack(val)
    else
       call read_entry(val, status, push=.true.)
       if (.not. status) return
    end if
    call set_result(val)
  end subroutine duppress

  subroutine oppress(widget, gdata) bind(c)
    ! One of the operators (including ATAN2, LCM, HCF). Gdata is a pointer
    ! to the operation code

    type(c_ptr), value :: widget, gdata

    integer(kind=c_int), pointer :: opcode
    integer(kind=c_int) :: mid, nchars
    real(kind=c_double) :: x, y, z
    logical :: status


    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end


    call set_result()
    nchars = int(gtk_entry_get_text_length(fentry), c_int)
    if (nchars > 0) then  ! Have a value in the entry window (will be X)
       call read_entry(x, status, push=.false.)
       if (.not. status) return

       call pop_stack(y, status)
       if (.not. status) return

       call gtk_entry_set_text(fentry, c_null_char)
    else
       call pop_stack(x, status)
       if (.not. status) return
       call pop_stack(y, status)
       if (.not. status) then
          call push_stack(x, show_result=.false.)
          return
       end if
    end if

    call c_f_pointer(gdata, opcode)
    select case(opcode)
    case (OP_PLUS)
       z = y+x
    case (OP_MINUS)
       z = y-x
    case (OP_TIMES)
       z = y*x
    case (OP_DIVIDE)
       z = y/x
    case (OP_POWER)
       ! If the inverse flag is set and the operation was initiated by
       ! the power button (rather than the ^ keystroke) take the root
       if (isinv .and. c_associated(widget)) x = 1._c_double/x
       if (is_int(x)) then  ! integer power safe for all signs
          z = y**int(x)

       else if (y < 0._c_double) then ! real power of a negative value
          ! (not allowed)
          mid = gtk_statusbar_push(fstatus, 0_c_int, &
               & "Cannot raise a negative value to a real power"//c_null_char)
          call push_stack(y, show_result=.false.)
          call push_stack(x, show_result=.false.)
          return
       else
          z = y**x
       end if
       if (isinv .and. c_associated(widget)) then ! Only power is
          !  affected by inverse flag
          call gtk_toggle_button_set_active(karc, FALSE)
          isinv = .FALSE.
          call set_labels
       end if
    case (FUN_ATAN2)
       z = atan2(y, x)
       select case(trigunit)
       case(1)
          z = z * 180._c_double/pi
       case(2)
          z = z * 200._c_double/pi
       case(0)
       end select
    case (FUN_MOD)
       z = modulo(y, x)
    case (FUN_HCF)
       if (.not. (is_int(x))) then
          mid = gtk_statusbar_push(fstatus, 0_c_int, &
               & "X-Value is not an integer."//c_null_char)
          return
       end if
       if (.not. (is_int(y))) then
          mid = gtk_statusbar_push(fstatus, 0_c_int, &
               & "Y-Value is not an integer."//c_null_char)
          return
       end if
       z = real(hcf(int(x, c_long), int(y, c_long)), c_double)
    case (FUN_LCM)
       if (.not. (is_int(x))) then
          mid = gtk_statusbar_push(fstatus, 0_c_int, &
               & "X-Value is not an integer."//c_null_char)
          return
       end if
       if (.not. (is_int(y))) then
          mid = gtk_statusbar_push(fstatus, 0_c_int, &
               & "Y-Value is not an integer."//c_null_char)
          return
       end if
       z = real(lcm(int(x, c_long), int(y, c_long)), c_double)
    end select

    call push_stack(z)
    call set_result(z)
    mid = gtk_statusbar_push(fstatus, 0_c_int, c_null_char)
  end subroutine oppress

  subroutine cepress(widget, gdata) bind(c)
    ! Clear entry: Delete the entry window or the top element of the stack
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int16_t) :: nchars
    real(kind=c_double) :: xjunk
    logical :: status
    integer(kind=c_int) :: mid

    nchars = gtk_entry_get_text_length(fentry)
    if (nchars > 0) then
       call gtk_entry_set_text(fentry, c_null_char)
       call clear_entry_flags
    else
       call pop_stack(xjunk, status)
    end if
    call set_result()
    mid = gtk_statusbar_push(fstatus, 0_c_int, c_null_char)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

  end subroutine cepress

  subroutine capress(widget, gdata) bind(c)
    ! Clear all
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int16_t) :: nchars
    integer(kind=c_int) :: mid

    call set_result()

    nchars = gtk_entry_get_text_length(fentry)
    if (nchars > 0) then
       call gtk_entry_set_text(fentry, c_null_char)
       call clear_entry_flags
    endif

    call hl_gtk_listn_rem(fstack)
    mid = gtk_statusbar_push(fstatus, 0_c_int, c_null_char)
    if (dynamic_stats) call stack_stats(0._c_double, clear=.true.)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end


  end subroutine capress

  subroutine uppress(widget, gdata) bind(c)
    ! Move the current selection up the stack
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: nchars, mid
    character(len=40) :: ftext
    real(kind=c_double) :: x, y
    logical :: status, sflag

    mid = gtk_statusbar_push(fstatus, 0_c_int, c_null_char)
    sflag = .true.

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

    if (stack_selected <= 0) then ! top element or none
       ! (swap with the entry box)
       nchars = int(gtk_entry_get_text_length(fentry), c_int)
       if (nchars == 0) then ! just pop the top of the stack to the box
          call pop_stack(x, status)
          sflag=.false.
          if (.not. status) return
          write(ftext,*) x
          call gtk_entry_set_text(fentry, trim(adjustl(ftext))//c_null_char)
       else
          call read_entry(x, status, push=.false.)
          if (.not. status) return
          call pop_stack(y, status)
          if (.not. status) return
          call push_stack(x)
          write(ftext,*) y
          call gtk_entry_set_text(fentry, trim(adjustl(ftext))//c_null_char)
       end if
       call hl_gtk_listn_set_selection(fstack)
    else
       call hl_gtk_listn_swap_rows(fstack, stack_selected, &
            & stack_selected-1_c_int)
       stack_selected = stack_selected-1
    end if
    if (sflag) then
       call pop_stack(x, status, readonly=.true.)
       if (status) call set_result(x)
    end if
  end subroutine uppress

  subroutine downpress(widget, gdata) bind(c)
    ! Move the current selection down the stack
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: nchars, mid
    type(c_ptr) :: ctext
    character(len=40) :: ftext
    character(len=80) :: iom
    integer :: ios
    real(kind=c_double) :: x, y
    integer(kind=c_int) :: isel, nrows
    logical :: status

    mid = gtk_statusbar_push(fstatus, 0_c_int, c_null_char)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

    if (stack_selected < 0) then ! no selection
       nchars = int(gtk_entry_get_text_length(fentry), c_int)
       if (nchars == 0) return ! No action of entry is empty

       ctext = gtk_entry_get_text(fentry)
       call convert_c_string(ctext, ftext)
       read(ftext, *, iostat=ios, iomsg=iom) x
       if (ios /= 0) then
          mid = gtk_statusbar_push(fstatus, 0_c_int, trim(iom)//c_null_char)
          return
       end if
       call pop_stack(y, status)
       if (.not. status) return
       call push_stack(x)
       write(ftext,*) y
       call gtk_entry_set_text(fentry, trim(adjustl(ftext))//c_null_char)
       call hl_gtk_listn_set_selection(fstack)
    else
       nrows = hl_gtk_listn_get_n_rows(fstack)
       if (nrows <= 1) return
       isel = min(stack_selected, nrows-2)
       call hl_gtk_listn_swap_rows(fstack, isel, isel+1_c_int)
       if (isel == stack_selected) then
          stack_selected = stack_selected+1
       else
          stack_selected = stack_selected-1
       end if
    end if
    call pop_stack(x, status, readonly=.true.)
    if (status) call set_result(x)
  end subroutine downpress

  subroutine rollpress(widget, gdata) bind(c)
    type(c_ptr), value :: widget, gdata

    real(kind=c_double) :: x
    logical :: status

    integer(kind=c_int), dimension(:), allocatable :: idx
    integer :: i, nshift
    integer(kind=c_int) :: nrows,mid

    mid = gtk_statusbar_push(fstatus, 0_c_int, c_null_char)
    nrows = hl_gtk_listn_get_n_rows(fstack)
    if (nrows <= 1) return  ! Empty or 1 row can't roll

    allocate(idx(nrows))
    if (isinv) then
       nshift=1
    else
       nshift=-1
    end if
    idx = (/ (i-1, i=1,nrows) /)
    idx = cshift(idx, nshift)
    call hl_gtk_listn_reorder(fstack, idx)

    call pop_stack(x, status, readonly=.true.)
    if (status) call set_result(x)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

    if (isinv) then
       call gtk_toggle_button_set_active(karc, FALSE)
       isinv=.false.
       call set_labels
    end if
  end subroutine rollpress

  subroutine funpress(widget, gdata) bind(c)
    ! The 1-argument functions. GDATA is a pointer to the
    ! function identifier.
    type(c_ptr), value :: widget, gdata

    real(kind=c_double) :: x, z, acf
    integer(kind=c_int), pointer :: funcode
    integer(kind=c_int) :: nchars, mid
    logical :: status
    integer :: i


    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

    call set_result()
    nchars = int(gtk_entry_get_text_length(fentry), c_int)
    if (nchars > 0) then
       call read_entry(x, status, push=.false.)
       if (.not. status) return
       call gtk_entry_set_text(fentry, c_null_char)
    else
       call pop_stack(x, status)
       if (.not. status) return
    end if

    select case(trigunit)
    case(0)      ! Radians
       acf = 1._c_double
    case(1)      ! Degrees
       acf = pi/180._c_double
    case(2)      ! Grads
       acf = pi/200._c_double
    end select

    call c_f_pointer(gdata, funcode)

    select case(funcode)
    case(FUN_SIN)
       if (isinv) then
          if (abs(x) > 1._c_double) then
             mid = gtk_statusbar_push(fstatus, 0_c_int, &
                  & "Asin argument out of range"//c_null_char)
             call push_stack(x, show_result=.false.)
             return
          end if
          z = asin(x)/acf
       else
          z = sin(x*acf)
       end if
    case(FUN_COS)
       if (isinv) then
          if (abs(x) > 1._c_double) then
             mid = gtk_statusbar_push(fstatus, 0_c_int, &
                  & "Acos argument out of range"//c_null_char)
             call push_stack(x, show_result=.false.)
             return
          end if
          z = acos(x)/acf
       else
          z = cos(x*acf)
       end if
    case(FUN_TAN)
       if (isinv) then
          z = atan(x)/acf
       else
          z = tan(x*acf)
       end if
    case(FUN_LN)
       if (isinv) then
          z = exp(x)
       else
          if (x <= 0._c_double) then
             mid = gtk_statusbar_push(fstatus, 0_c_int, &
                  & "Ln argument out of range"//c_null_char)
             call push_stack(x, show_result=.false.)
             return
          end if
          z = log(x)
       end if
    case(FUN_SQRT)
       if (isinv) then
          z = x**2
       else
          if (x <= 0._c_double) then
             mid = gtk_statusbar_push(fstatus, 0_c_int, &
                  & "Sqrt argument out of range"//c_null_char)
             call push_stack(x, show_result=.false.)
             return
          end if
          z = sqrt(x)
       end if
    case(FUN_SINH)
       if (isinv) then
          z = asinh(x)
       else
          z = sinh(x)
       end if
    case(FUN_COSH)
       if (isinv) then
          if (x < 1._c_double) then
             mid = gtk_statusbar_push(fstatus, 0_c_int, &
                  & "Acosh argument out of range"//c_null_char)
             call push_stack(x, show_result=.false.)
             return
          end if
          z = acosh(x)
       else
          z = cosh(x)
       end if
    case(FUN_TANH)
       if (isinv) then
          if (abs(x) > 1._c_double) then
             mid = gtk_statusbar_push(fstatus, 0_c_int, &
                  & "Atanh argument out of range"//c_null_char)
             call push_stack(x, show_result=.false.)
             return
          end if
          z = atanh(x)
       else
          z = tanh(x)
       end if
    case(FUN_LOG10)
       if (isinv) then
          z = 10._c_double ** x
       else
          if (x <= 0._c_double) then
             mid = gtk_statusbar_push(fstatus, 0_c_int, &
                  & "Log10 argument out of range"//c_null_char)
             call push_stack(x, show_result=.false.)
             return
          end if
          z = log10(x)
       end if
    case(FUN_INV)
       if (x == 0._c_double) then
          mid = gtk_statusbar_push(fstatus, 0_c_int, &
               & "Zero argument for 1/X in not permitted"//c_null_char)
          call push_stack(x, show_result=.false.)
          return
       end if
       z = 1._c_double / x
    case(FUN_ABS)
       z = abs(x)
    case(FUN_INT)
       z = aint(x)
    case(FUN_ROUND)
       z = anint(x)
    case(FUN_FRAC)
       z = x - aint(x)
    case(FUN_FACTORIAL)
       if (is_int(x) .and. x >= 0) then
          z = 1._c_double
          do i = 2, int(x)
             z = z*real(i, c_double)
          end do
       else
          mid = gtk_statusbar_push(fstatus, 0_c_int, &
               & "Factorial argument out of range or not an integer"&
               & //c_null_char)
          call push_stack(x, show_result=.false.)
          return
       end if
    end select
    call push_stack(z)
    mid = gtk_statusbar_push(fstatus, 0_c_int, c_null_char)
    if (isinv) then
       call gtk_toggle_button_set_active(karc, FALSE)
       isinv = .FALSE.
       call set_labels
    end if
  end subroutine funpress

  subroutine hmspress(widget, gdata) bind(c)
    ! Display the entry box or top of stack in HMS format
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: nchars, mid
    logical :: status
    real(kind=c_double) :: val


    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

    nchars=int(gtk_entry_get_text_length(fentry), c_int)
    if (nchars > 0) then
       call read_entry(val, status,push=.false.)
       if (.not. status) return
    else
       call pop_stack(val, status, readonly=.TRUE.)
       if (.not. status) return
    end if
    call show_hms(val, fresult)
    mid = gtk_statusbar_push(fstatus, 0_c_int, c_null_char)
  end subroutine hmspress

  subroutine base_display(widget, gdata) bind(c)
    ! Display a value in hex, octal or binary
    type(c_ptr), value :: widget, gdata

    real(kind=c_double) :: val
    integer(kind=c_long) :: ival
    integer(kind=c_int) :: nchars, mid
    logical :: status
    integer(kind=c_int), pointer :: base
    character(len=65,kind=c_char) :: result
    character(len=12) :: fmt

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

    nchars=int(gtk_entry_get_text_length(fentry), c_int)
    if (nchars > 0) then
       call read_entry(val, status, push=.false.)
       if (.not. status) return
    else
       call pop_stack(val, status, readonly=.TRUE.)
       if (.not. status) return
    end if

    if (.not. is_int(val)) then
       mid = gtk_statusbar_push(fstatus, 0_c_int, &
            & "Value is not an integer."//c_null_char)
       return
    end if
    if (abs(val) > real(huge(1_c_long),c_double)) then
       mid = gtk_statusbar_push(fstatus, 0_c_int, &
            & "Value is too large."//c_null_char)
       return
    end if
    ival = int(val,kind=c_double)

    call c_f_pointer(gdata, base)
    select case (base)
    case(2)
       if (leading_zeroes) then
          fmt = "(B64.64,'b')"
       else 
          fmt = "(B0,'b')"
       end if
    case(8)
       if (leading_zeroes) then
          fmt = "(O22.22,'o')"
       else 
          fmt = "(O0,'o')"
       end if
    case(16)
       if (leading_zeroes) then
          fmt = "(Z16.16,'x')"
       else 
          fmt = "(Z0,'x')"
       end if
    case default
       mid = gtk_statusbar_push(fstatus, 0_c_int, &
            & "Invalid base specified."//c_null_char)
       return
    end select
    write(result, fmt) ival

    call gtk_entry_set_text(fresult, trim(result)//c_null_char)
    mid = gtk_statusbar_push(fstatus, 0_c_int, c_null_char)
  end subroutine base_display

  subroutine invtoggle(widget, gdata) bind(c)
    ! Toggle inverse functions
    type(c_ptr), value :: widget, gdata

    isinv = (gtk_toggle_button_get_active(widget) == TRUE)
    call set_labels

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

  end subroutine invtoggle

  subroutine set_trigunit(widget, gdata) bind(c)
    ! Select trig units
    type(c_ptr), value :: widget, gdata

    trigunit = gtk_combo_box_get_active(widget)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

  end subroutine set_trigunit

  subroutine stacksel(widget, gdata) bind(c)
    ! Select an item on the stack
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: count
    integer(kind=c_int), dimension(:), allocatable :: sellist

    count = hl_gtk_listn_get_selections(fstack, sellist)
    if (count == 0) then
       stack_selected = -1
    else
       stack_selected = sellist(1)
       deallocate(sellist)
    end if

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

  end subroutine stacksel

  subroutine mempress(widget, gdata) bind(c)
    ! A memory key.
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int), pointer :: memop
    integer(kind=c_int) :: midx
    real(kind=c_double) :: x, y
    integer(kind=c_int) :: nchars, mid
    logical :: status, need_x, entry_index

    call c_f_pointer(gdata, memop)

    need_x = .not. (memop == MEM_RCL .or. memop == MEM_CLR .or. &
         & memop == MEM_CLA)

    nchars = gtk_entry_get_text_length(fentry)


    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end


    if (memop /= MEM_CLA) then
       if (mem_selected >= 0) then ! A register is selected by the list
          midx = mem_selected
          if (need_x) then
             if (nchars > 0) then
                call read_entry(x, status, push=.false.)
             else
                call pop_stack(x, status, readonly=.true.)
             end if
             if (.not. status) return
          end if
          entry_index=.false.
       else
          if (nchars == 0) then
             mid = gtk_statusbar_push(fstatus, 0_c_int, &
                  & "No content in entry and no register selected"//c_null_char)
             return
          end if
          call read_entry(midx, status)
          if (.not. status .or. midx < 0 .or. midx > maxreg) then
             mid = gtk_statusbar_push(fstatus, 0_c_int, &
                  & "Entry field is not a valid register"//c_null_char)
             return
          end if
          entry_index=.true.
          if (need_x) then
             call pop_stack(x, status, readonly=.true.)
             if (.not. status) return
          end if
       end if
    end if

    select case(memop)
    case(MEM_STO)
       call hl_gtk_listn_set_cell(fmemory, midx, 1_c_int, dvalue=x)
    case(MEM_RCL)
       call hl_gtk_listn_get_cell(fmemory, midx, 1_c_int, dvalue=y)
       call push_stack(y)
    case(MEM_PLUS)
       call hl_gtk_listn_get_cell(fmemory, midx, 1_c_int, dvalue=y)
       call hl_gtk_listn_set_cell(fmemory, midx, 1_c_int, dvalue=y+x)
    case(MEM_MINUS)
       call hl_gtk_listn_get_cell(fmemory, midx, 1_c_int, dvalue=y)
       call hl_gtk_listn_set_cell(fmemory, midx, 1_c_int, dvalue=y-x)
    case(MEM_CLR)
       call hl_gtk_listn_set_cell(fmemory, midx, 1_c_int, dvalue=0._c_double)
    case(MEM_CLA)
       do midx = 0, maxreg
          call hl_gtk_listn_set_cell(fmemory, midx, 1_c_int, dvalue=0._c_double)
       end do
    end select

    call hl_gtk_listn_set_selection(fmemory)
    mem_selected = -1
    if (entry_index) call gtk_entry_set_text(fentry, c_null_char)
    mid = gtk_statusbar_push(fstatus, 0_c_int, c_null_char)
  end subroutine mempress

  subroutine memsel(widget, gdata) bind(c)
    ! A selection in the registers list
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: count
    integer(kind=c_int), dimension(:), allocatable :: sellist

    count = hl_gtk_listn_get_selections(fmemory, sellist)
    if (count == 0) then
       mem_selected = -1
    else
       mem_selected = sellist(1)
       deallocate(sellist)
    end if

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

  end subroutine memsel

  subroutine save_values(widget, gdata) bind(c)
    ! Save the stack and registers
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: response
    character(len=256), dimension(:), allocatable :: file

    response = hl_gtk_file_chooser_show(file, confirm_overwrite=TRUE, &
         & parent=win, filter=(/"*.rpn"/), &
         & filter_name=(/"RPN save files"/), edit_filters=TRUE)


    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

    if (response == FALSE) return

    call save_all(file(1))
    deallocate(file)

  end subroutine save_values

  subroutine restore_values(widget, gdata) bind(c)
    ! restore the stack and registers
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: response
    character(len=256), dimension(:), allocatable :: file

    response = hl_gtk_file_chooser_show(file, create=FALSE, &
         & parent=win, filter=(/"*.rpn"/), &
         & filter_name=(/"RPN save files"/), edit_filters=TRUE)


    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

    if (response == FALSE) return

    call restore_all(file(1))

    deallocate(file)

  end subroutine restore_values

  subroutine show_help(widget, gdata) bind(c)
    ! Display help text
    type(c_ptr), value :: widget, gdata

    character(len=*), parameter :: textfile="@TEXTFILE@"
    character(len=*), parameter :: pdffile="@PDFFILE@"
    type(c_ptr) :: hscroll, hview, hquit, hbox
    character(kind=c_char), dimension(:), allocatable, save :: text
    integer :: unit, iostat, textlen
    character(len=80) :: iomsg
    character(len=80) :: pdfviewer

    call find_pdf_reader(pdfviewer)

    if (pdfviewer /= '') then
       call execute_command_line(trim(pdfviewer)//' '//pdffile, wait=.false.)
    else
       if (.not. allocated(text)) then
          ! Note that the easiest way to read a whole file into an array
          ! of CHAR*1 is to open it as an unformatted stream.
          open(newunit=unit, file=textfile, access='stream', action='read', &
               & iostat=iostat, iomsg=iomsg, form="unformatted")
          if (iostat /= 0) then
             write(error_unit, "(2A)") "rpncalc: Failed to open help file: ", &
                  & trim(textfile)
             write(error_unit, "(2A)") "Reason: ", trim(iomsg)
             return
          end if
          inquire(unit, size=textlen)
          allocate(text(textlen))
          read(unit, iostat=iostat, iomsg=iomsg) text
          if (iostat /= 0) then
             write(error_unit, *) "rpncalc: Failed to read help file: ", &
                  & trim(textfile)
             write(error_unit, *) "Reason: ", trim(iomsg)
             return
          end if
          close(unit)
       end if

       help_window = hl_gtk_window_new("RPN Calculator"//c_null_char, &
            & deletable=FALSE, above=TRUE, parent=win)

       hbox = hl_gtk_box_new()
       call gtk_container_add(help_window, hbox)

       hview = hl_gtk_text_view_new(hscroll, editable=FALSE, &
            & ssize=(/700_c_int, 600_c_int/), initial_text = text)
       call hl_gtk_box_pack(hbox, hscroll)

       hquit = hl_gtk_button_new("Dismiss"//c_null_char, &
            & clicked=c_funloc(help_del))

       call hl_gtk_box_pack(hbox, hquit)

       call gtk_widget_show_all(help_window)

    end if

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

  end subroutine show_help

  subroutine help_del(widget, gdata) bind(c)
    ! Delete help window
    type(c_ptr), value :: widget, gdata

    call gtk_widget_destroy(help_window)
  end subroutine help_del


  subroutine about_rpn(widget, gdata) bind(c)
    ! Display an about dialogue
    type(c_ptr), value :: widget, gdata

    call hl_gtk_about_dialog_show(name="RPN Calculator"//c_null_char, &
         & authors=(/ "James Tappin" /), comments=&
         & "This RPN calculator is a demonstration"//c_new_line// &
         & "of the capabilities of Gtk-fortran."//c_new_line//c_new_line// &
         & "It is entirely written in Fortran 95/2003."//c_new_line// &
         & "It should work with both Gtk+-2.24 and 3.x"//c_null_char, &
         & website="https://github.com/jtappin/RPNcalc/wiki"//c_null_char, &
         & license="GNU GPL 3"//c_null_char, parent=win)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

  end subroutine about_rpn

  subroutine about_gtkfortran (widget, gdata )  bind(c)
    ! About Gtk Fortran info.
    type(c_ptr), value :: widget, gdata

    call hl_gtk_about_dialog_gtk_fortran(win)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

  end subroutine about_gtkfortran

  subroutine set_format_make(widget, gdata) bind(c)
    ! Dialog to set up the format for data display.
    type(c_ptr), value :: widget, gdata

    type(c_ptr) :: jb, jbb, junk
    integer(kind=c_int) :: issens

    fmt_window = hl_gtk_window_new("Set format"//c_null_char, above=TRUE, &
         & destroy=c_funloc(set_format_destroy), parent=win)

    jb = hl_gtk_box_new()
    call gtk_container_add(fmt_window, jb)

    jbb = hl_gtk_box_new(horizontal=TRUE)
    call hl_gtk_box_pack(jb, jbb)
    junk = gtk_label_new("Current format = "//trim(result_format)//c_null_char)
    call hl_gtk_box_pack(jbb, junk, expand=FALSE)

    jbb = hl_gtk_box_new(horizontal=TRUE)
    call hl_gtk_box_pack(jb, jbb)
    junk = gtk_label_new("Format:"//c_null_char)
    call hl_gtk_box_pack(jbb, junk, expand=FALSE)
    fmt_choose = hl_gtk_combo_box_new(has_entry=TRUE, &
         & changed=c_funloc(set_format_type_cb), &
         & initial_choices=(/"Fixed   (F)", "Sci    (ES)", "Eng    (EN)", &
         & "General (G)", "Free    (*)"/), &
         & active = fmt_type, &
         & tooltip="Choose a format type or give a Fortran format code" &
         & //c_null_char)
    call hl_gtk_box_pack(jbb, fmt_choose)

    jbb = hl_gtk_box_new(horizontal=TRUE)
    call hl_gtk_box_pack(jb, jbb)
    junk = gtk_label_new("Precision:"//c_null_char)
    call hl_gtk_box_pack(jbb, junk, expand=FALSE)
    if (fmt_type >= 0 .and. fmt_type <= 3) then
       issens = TRUE
    else
       issens=FALSE
    end if
    fmt_precision = hl_gtk_spin_button_new(1_c_int, 30_c_int, &
         & initial_value=fmt_decimal, &
         & sensitive=issens, tooltip="Set the number of decimal places"&
         & //c_null_char)
    call hl_gtk_box_pack(jbb, fmt_precision)
    junk = gtk_label_new("Exponent:"//c_null_char)
    call hl_gtk_box_pack(jbb, junk, expand=FALSE)
    if (fmt_type >= 1 .and. fmt_type <= 3) then
       issens = TRUE
    else
       issens=FALSE
    end if
    fmt_expsize = hl_gtk_spin_button_new(1_c_int, 3_c_int, &
         & initial_value=fmt_expplaces,&
         & sensitive=issens, tooltip="Set the width of the exponent"&
         & //c_null_char)
    call hl_gtk_box_pack(jbb, fmt_expsize)

    junk = hl_gtk_separator_new()
    call hl_gtk_box_pack(jb, junk)
    jbb = hl_gtk_box_new(horizontal=TRUE)
    call hl_gtk_box_pack(jb, jbb)
    junk = hl_gtk_check_button_new("Show leading zeroes in base-n displays?" &
         & //c_null_char, toggled=c_funloc(set_format_zeroes), &
         & initial_state = f_c_logical(leading_zeroes), &
         & tooltip = "Control display of leading zeroes in base-n displays"&
         & //c_null_char)
    call hl_gtk_box_pack(jbb, junk)

    jbb = hl_gtk_box_new(horizontal=TRUE)
    call hl_gtk_box_pack(jb, jbb)
    junk = hl_gtk_button_new("Apply"//c_null_char, &
         & clicked=c_funloc(set_format_cb))
    call hl_gtk_box_pack(jbb, junk)
    junk = hl_gtk_button_new("Cancel"//c_null_char, &
         & clicked=c_funloc(set_format_destroy))
    call hl_gtk_box_pack(jbb, junk)
    call gtk_widget_show_all(fmt_window)
  end subroutine set_format_make

  subroutine set_format_type_cb(widget, gdata) bind(c)
    ! Set the display format type
    type(c_ptr), value :: widget, gdata

    ! Return if this is called during the setup
    if (.not. c_associated(fmt_precision)) return

    fmt_type = hl_gtk_combo_box_get_active(widget)

    select case(fmt_type)
    case(0)             ! Fixed
       call gtk_widget_set_sensitive(fmt_precision, TRUE)
       call gtk_widget_set_sensitive(fmt_expsize, FALSE)
    case(1,2,3)           ! Sci, eng, general
       call gtk_widget_set_sensitive(fmt_precision, TRUE)
       call gtk_widget_set_sensitive(fmt_expsize, TRUE)
    case(4,-1)          ! Free, explicit
       call gtk_widget_set_sensitive(fmt_precision, FALSE)
       call gtk_widget_set_sensitive(fmt_expsize, FALSE)
    end select
  end subroutine set_format_type_cb

  subroutine set_format_cb(widget, gdata) bind(c)
    ! Set the display format
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: nchars, dummy
    character(len=40) :: res_tmp
    integer :: idxc, idxo

    select case(fmt_type)
    case(0)                ! Fixed
       fmt_decimal = gtk_spin_button_get_value_as_int(fmt_precision)
       write(result_format,"('(F0.',i0')')") fmt_decimal
    case(1)                ! Scientific
       fmt_decimal = gtk_spin_button_get_value_as_int(fmt_precision)
       fmt_expplaces = gtk_spin_button_get_value_as_int(fmt_expsize)
       nchars = 5+fmt_decimal+fmt_expplaces
       write(result_format, "('(ES',i0,'.',i0,'e',i0,')')") nchars, &
            & fmt_decimal, fmt_expplaces
    case(2)                ! Engineering
       fmt_decimal = gtk_spin_button_get_value_as_int(fmt_precision)
       fmt_expplaces = gtk_spin_button_get_value_as_int(fmt_expsize)
       nchars = 7+fmt_decimal+fmt_expplaces
       write(result_format, "('(EN',i0,'.',i0,'e',i0,')')") nchars, &
            & fmt_decimal, fmt_expplaces
    case(3)                ! General
       fmt_decimal = gtk_spin_button_get_value_as_int(fmt_precision)
       fmt_expplaces = gtk_spin_button_get_value_as_int(fmt_expsize)
       nchars = 5+fmt_decimal+fmt_expplaces
       write(result_format, "('(G',i0,'.',i0,'e',i0,')')") nchars, &
            & fmt_decimal, fmt_expplaces
    case(4)                ! List-directed
       result_format = ''
    case(-1)               ! An explicit format
       dummy = hl_gtk_combo_box_get_active(fmt_choose, ftext = res_tmp)
       if (res_tmp == "*") then
          result_format = ''
       else
          idxo = index(res_tmp, "(")
          idxc = index(res_tmp, ")", back=.true.)
          if (idxc /= len_trim(res_tmp)) res_tmp = trim(res_tmp)//")"
          if (idxo /= 1) res_tmp="("//res_tmp
          result_format=res_tmp
       end if
    end select

    call gtk_widget_destroy(fmt_window)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

  end subroutine set_format_cb

  subroutine set_format_destroy(widget, gdata) bind(c)
    ! Don't set the display format
    type(c_ptr), value :: widget, gdata

    call gtk_widget_destroy(fmt_window)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

  end subroutine set_format_destroy

  subroutine set_format_zeroes(widget, gdata) bind(c)
    ! Set / Unset leading zeroes.

    type(c_ptr), value :: widget, gdata

    leading_zeroes = c_f_logical(gtk_toggle_button_get_active(widget))

  end subroutine set_format_zeroes
  subroutine set_stats(widget, gdata) bind(c)
    ! Compute stats of the stack.
    type(c_ptr), value :: widget, gdata

    dynamic_stats = (gtk_toggle_button_get_active(widget) == TRUE)
    if (dynamic_stats) call stack_stats(0._c_double, initialize=.true.)

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

  end subroutine set_stats

  subroutine statsel(widget, gdata) bind(c)
    ! Copy stats to the stack.
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: count, i
    integer(kind=c_int), dimension(:), allocatable :: sellist
    real(kind=c_double) :: x

    count = hl_gtk_listn_get_selections(fstats, sellist)
    if (count > 0) then
       do i = 1, count
          call hl_gtk_listn_get_cell(fstats, sellist(i), 1_c_int, dvalue=x)
          call push_stack(x)
       end do
       deallocate(sellist)
    end if

    call gtk_widget_grab_focus(fentry)
    call gtk_editable_set_position(fentry, -1_c_int)   ! Put cursor at end

  end subroutine statsel

  subroutine set_dms_hms(widget, gdata) bind(c)
    ! Set format of degrees or hours minutes seconds display.
    type(c_ptr), value :: widget, gdata

    dms_hms = c_f_logical(gtk_check_menu_item_get_active(widget))
    if (dms_hms) then
       call gtk_menu_item_set_label(khms, "DMS"//c_null_char)
    else
       call gtk_menu_item_set_label(khms, "HMS"//c_null_char)
    end if
  end subroutine set_dms_hms

  subroutine add_remove_registers(widget, gdata) bind(c)
    ! Add or remove registers according to the setting of the register count.
    type(c_ptr), value :: widget, gdata

    integer(kind=c_int) :: nreg, nsel
    integer(kind=c_int) :: i
    integer(kind=c_int), dimension(:), allocatable :: selected

    ! Since any valid INTEGER can be represented exactly by any double,
    ! we don't need to worry about using nint etc.

    nreg = int(hl_gtk_spin_button_get_value(widget))

    if (nreg > maxreg+1) then
       do i = maxreg+1, nreg-1
          call hl_gtk_listn_ins(fmemory)   ! Default is append
          call hl_gtk_listn_set_cell(fmemory, i, 0_c_int, ivalue=i)
          call hl_gtk_listn_set_cell(fmemory, i, 1_c_int, dvalue=0._c_double)
       end do
    else if (nreg < maxreg+1) then
       nsel = hl_gtk_listn_get_selections(fmemory, selected)
       if (nsel > 0) then
          if (any(selected >= nreg)) then
             call hl_gtk_listn_set_selection(fmemory)
             mem_selected = -1
          end if
       end if
       do i = maxreg, nreg, -1
          call hl_gtk_listn_rem(fmemory, i)
       end do
    end if
    maxreg = nreg-1
  end subroutine add_remove_registers

 subroutine set_pdf_reader(widget, data) bind(c)
   type(c_ptr), value :: widget, data

    ! Set a pdf reader manually.

    logical, dimension(size(pdf_readers)) :: isinstalled
    integer :: i, j, nfound
    character(len=len(pdf_readers)), dimension(:), allocatable :: list
    type(c_ptr) :: pbase, jb, junk
    integer(kind=c_int) :: ichoice

    do i = 1, size(pdf_readers)
       isinstalled(i) = check_command(pdf_readers(i))
    end do
    nfound = count(isinstalled)

    if (pdf_is_init .and. pdf_reader /= '' .and. &
         & count(pdf_reader == pdf_readers) == 0) then
       allocate(list(nfound+2))
       list(nfound+2) = pdf_reader
       ichoice = nfound+1
    else
       allocate(list(nfound+1))
       ichoice = -1
    end if

    list(1) = 'Text'
    if (pdf_is_init .and. pdf_reader == '') ichoice = 0

    if (nfound > 0) then
       j = 2
       do i = 1, size(pdf_readers)
          if (isinstalled(i)) then
             list(j) = pdf_readers(i)
             if (list(j) == pdf_reader .and. pdf_is_init) &
                  & ichoice = j-1
             j = j+1
          end if
       end do
    end if

    pwin = hl_gtk_window_new("Choose PDF viewer"//c_null_char, &
         & above=TRUE, parent=win, destroy=c_funloc(set_pdf_destroy))

    pbase = hl_gtk_box_new()
    call gtk_container_add(pwin, pbase)

    jb = hl_gtk_box_new(horizontal=TRUE)
    call hl_gtk_box_pack(pbase, jb)

    junk = gtk_label_new("Viewer:"//c_null_char)
    call hl_gtk_box_pack(jb, junk)

    pchoose = hl_gtk_combo_box_new(has_entry=TRUE, &
         & initial_choices=list, active=ichoice, &
         & changed=c_funloc(set_pdf_pick), tooltip=&
         & "Pick a pdf reader or enter your favourite"//c_null_char)
    call hl_gtk_box_pack(jb, pchoose)

    jb = hl_gtk_box_new(horizontal=TRUE)
    call hl_gtk_box_pack(pbase, jb)
    pbut = hl_gtk_button_new("Apply"//c_null_char, &
         & sensitive=FALSE, clicked=c_funloc(set_pdf_apply), &
         & tooltip="Apply the viewer selection"//c_null_char)
    call hl_gtk_box_pack(jb, pbut)

    junk = hl_gtk_button_new("Cancel"//c_null_char, &
         & clicked=c_funloc(set_pdf_destroy), &
         & tooltip="Cancel, keep the existing selection"//c_null_char)
    call hl_gtk_box_pack(jb, junk)

    call gtk_widget_show_all(pwin)

  end subroutine set_pdf_reader

  subroutine set_pdf_destroy(widget, data) bind(c)
    type(c_ptr), value :: widget, data

    call gtk_widget_destroy(pwin)

  end subroutine set_pdf_destroy

  subroutine set_pdf_apply(widget, data) bind(c)
    type(c_ptr), value :: widget, data

    integer(kind=c_int) :: idx
    character(len=len(pdf_reader)) :: pval

    if (.not.c_associated(pchoose)) return

    idx = hl_gtk_combo_box_get_active(pchoose, ftext=pval)

    if (pval == 'Text') then
       pdf_reader = ''
    else
       pdf_reader = pval
    end if
    pdf_is_init = .true.

    call gtk_widget_destroy(pwin)
  end subroutine set_pdf_apply

  subroutine set_pdf_pick(widget, data) bind(c)
    type(c_ptr), value :: widget, data

    integer(kind=c_int) :: idx
    character(len=len(pdf_reader)) :: pval

    if (.not.c_associated(pchoose)) return

    idx = hl_gtk_combo_box_get_active(pchoose, ftext=pval)

    if (idx >= 0) then
       call gtk_widget_set_sensitive(pbut, TRUE)
    else
       call gtk_widget_set_sensitive(pbut, &
            & f_c_logical(check_command(pval)))
    end if
  end subroutine set_pdf_pick

end module handlers
